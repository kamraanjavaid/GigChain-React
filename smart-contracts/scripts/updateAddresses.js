const fs = require("fs");
const path = require("path");

async function updateAddresses(network, contractAddress) {
  try {
    const addressesPath = path.join(
      __dirname,
      "../../frontend/src/contracts/addresses.js"
    );

    let addresses = {};
    try {
      const currentContent = fs.readFileSync(addressesPath, "utf8");
      const match = currentContent.match(/CONTRACT_ADDRESSES = ({[\s\S]*?});/);
      if (match) {
        addresses = JSON.parse(match[1]);
      }
    } catch (error) {
      console.log("Creating new addresses file");
    }

    addresses[network.chainId] = {
      name: network.name,
      FreelanceMarketplace: contractAddress,
    };

    const content = `// Auto-generated by deployment script
export const CONTRACT_ADDRESSES = ${JSON.stringify(addresses, null, 2)};

// Helper function to get contract address by chain ID
export const getContractAddress = (chainId, contractName = 'FreelanceMarketplace') => {
  const network = CONTRACT_ADDRESSES[chainId];
  if (!network) {
    throw new Error(\`Unsupported network chain ID: \${chainId}\`);
  }
  
  const address = network[contractName];
  if (!address) {
    throw new Error(\`Contract \${contractName} not deployed on network \${network.name}\`);
  }
  
  return address;
};

// Helper function to check if network is supported
export const isSupportedNetwork = (chainId) => {
  return Object.keys(CONTRACT_ADDRESSES).includes(chainId.toString());
};

// Get network name helper
export const getNetworkName = (chainId) => {
  return CONTRACT_ADDRESSES[chainId]?.name || 'unknown';
};
`;

    const dir = path.dirname(addressesPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(addressesPath, content);
    console.log(`Updated addresses file at ${addressesPath}`);
  } catch (error) {
    console.error("Error updating addresses:", error);
    throw error;
  }
}

module.exports = { updateAddresses };
